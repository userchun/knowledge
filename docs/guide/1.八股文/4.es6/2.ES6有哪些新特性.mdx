# 2.ES6有哪些新特性

ES6（ECMAScript 2015）引入了许多新特性，以下是一些主要的新特性：

#### 一. **箭头函数**：

使用`=>`定义函数，简化了函数的书写，并且不绑定自己的`this`。

```js
const add = (a, b) => a + b;
```

#### 二. **模板字符串**：

使用反引号（``）定义字符串，支持多行字符串和变量插值。

```js
const name = 'Alice';
const greeting = `Hello, ${name}!`;
```

#### 三. **解构赋值**：

从数组或对象中提取值，并赋给变量。

```js
const [a, b] = [1, 2];
const { name, age } = { name: 'Alice', age: 25 };
```

#### 四. **默认参数**：

函数参数可以设置默认值。

```js
function greet(name = 'World') {
  console.log(`Hello, ${name}!`);
}
```

#### 五. **展开运算符**：

使用`...`展开数组或对象。

```js
const arr1 = [1, 2, 3];
const arr2 = [...arr1, 4, 5]; // [1, 2, 3, 4, 5]
```

#### 六. **类和模块**：

引入了类的语法和模块化机制。

```js
class Person {
  constructor(name) {
    this.name = name;
  }
  greet() {
    console.log(`Hello, ${this.name}!`);
  }
}
```

#### 七. **Promise**：

用于处理异步操作，避免回调地狱。

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Success');
  }, 1000);
});

promise.then((result) => {
  console.log(result); // Success
});
```

#### 八. **Set和Map**：

新的数据结构，Set用于存储唯一值，Map用于存储键值对。

```js
const set = new Set([1, 2, 3]);
set.add(4);
set.delete(2);
console.log(set.has(3)); // true

const map = new Map();

map.set('name', 'Alice');
map.set('age', 25);
console.log(map.get('name')); // Alice
```

#### 九. **模块化**：

使用`import`和`export`进行模块化编程。

```js
// 导出模块
export const PI = 3.14;
export function add(a, b) {
  return a + b;
}

// 导入模块
import { PI, add } from './math.js';
console.log(PI); // 3.14
console.log(add(2, 3)); // 5
```

#### 十. **Symbol**：

用于创建唯一的标识符。

    ```js
    const sym1 = Symbol('description');
    const sym2 = Symbol('description');
    console.log(sym1 === sym2); // false
    ```

#### 十一. **迭代器和生成器**：

提供了一种遍历数据结构的统一方式。

- 迭代器

```js
const arr = [1, 2, 3];
const iterator = arr[Symbol.iterator]();

console.log(iterator.next().value); // 1
console.log(iterator.next().value); // 2
console.log(iterator.next().value); // 3
```

- 生成器

```js
function* generator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = generator();
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3
```

- for of 循环可以直接遍历生成器

```js
for (const value of generator()) {
  console.log(value); // 1, 2, 3
}
```

#### 十二. **Promise**:

用于处理异步操作，避免回调地狱。

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Success');
  }, 1000);
});

promise.then((result) => {
  console.log(result); // Success
});
```

Promise 方法：`then`、`catch`、`finally`、`all`、`race`、`allSettled`、`any`

- Promise.all: 等待所有Promise完成
- Promise.race: 等待第一个Promise完成，无论成功或失败
- Promise.allSettled: 等待所有Promise完成，无论成功或失败
- Promise.any: 等待第一个成功的Promise
- Promise.finally: 无论成功或失败，都会执行

#### 十三. **异步编程**:

引入了`async`和`await`，使异步代码更易读。

```js
async function fetchData() {
  const response = await fetch('https://api.example.com/data');
  const data = await response.json();
  console.log(data);
}
```

#### 十四. 拦截器（Proxy）：

用于创建对象的代理，从而可以拦截和定义基本操作（如属性查找、赋值、枚举、函数调用等）。

```js
const target = { name: 'Alice' };
const handler = {
  get: (obj, prop) => {
    console.log(`Getting ${prop}`);
    return obj[prop];
  },
  set: (obj, prop, value) => {
    console.log(`Setting ${prop} to ${value}`);
    obj[prop] = value;
    return true;
  },
};

const proxy = new Proxy(target, handler);
console.log(proxy.name); // Getting name, Alice
proxy.age = 25; // Setting age to 25
```

#### 十五. **Reflect**：

提供了一些静态方法，用于操作对象，给对象添加一些属性和方法。

```js
const obj = { name: 'Alice' };
Reflect.set(obj, 'age', 25);
console.log(Reflect.get(obj, 'name')); // Alice
console.log(Reflect.get(obj, 'age')); // 25
```

#### 十六. **尾调用优化**：

在某些情况下，函数的最后一个操作是调用另一个函数，ES6对这种情况进行了优化，减少了调用栈的增长。

```js
function factorial(n, acc = 1) {
  if (n <= 1) return acc;
  return factorial(n - 1, n * acc); // 尾调用
}
console.log(factorial(5)); // 120
```

#### 十七. **私有字段和方法**：

使用`#`定义类的私有字段和方法。

```js
class Person {
  #name; // 私有字段
  constructor(name) {
    this.#name = name;
  }
  #greet() {
    // 私有方法
    console.log(`Hello, ${this.#name}!`);
  }
}
```

#### 十八. **动态导入**：

使用`import()`函数动态导入模块。

```js
import('./module.js').then((module) => {
  module.doSomething();
});
```

#### 十九. **BigInt**：

用于表示大整数，超出`Number`类型的安全范围。

```js
const bigInt = BigInt(9007199254740991);
console.log(bigInt + 1n); // 9007199254740992n
```

#### 二十. **异步迭代器**：

使用`for await...of`循环异步遍历数据。

```js
async function* asyncGenerator() {
  yield 'Hello';
  yield 'World';
}
(async () => {
  for await (const value of asyncGenerator()) {
    console.log(value);
  }
})();
```

#### 二十一. **ArrayBuffer**:

用于处理二进制数据。

```js
const buffer = new ArrayBuffer(16); // 创建一个16字节的缓冲区
const view = new Uint32Array(buffer); // 创建一个视图来操作缓冲区
view[0] = 42;
console.log(view[0]); // 42
```
